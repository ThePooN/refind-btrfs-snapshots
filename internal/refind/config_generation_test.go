package refind

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/jmylchreest/refind-btrfs-snapshots/internal/btrfs"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateManagedConfigDiff_NewFile_GeneratesTemplate(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	// Create test snapshots
	now := time.Now()
	snapshots := []*btrfs.Snapshot{
		{
			Subvolume: &btrfs.Subvolume{
				ID:   101,
				Path: "/.snapshots/101/snapshot",
			},
			SnapshotTime: now.Add(-1 * time.Hour),
		},
		{
			Subvolume: &btrfs.Subvolume{
				ID:   100,
				Path: "/.snapshots/100/snapshot",
			},
			SnapshotTime: now.Add(-2 * time.Hour),
		},
	}
	
	// Create test source entries (these would normally come from multiple refind_linux.conf entries)
	sourceEntries := []*MenuEntry{
		{
			Title:   "Boot with standard options",
			Options: "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid",
		},
	}
	
	rootFS := &btrfs.Filesystem{
		UUID: "test-uuid",
		Subvolume: &btrfs.Subvolume{
			Path: "@",
		},
	}
	
	// Generate config for a new file (file doesn't exist)
	diff, err := generator.GenerateManagedConfigDiff(sourceEntries, snapshots, rootFS, "/nonexistent/path/refind-btrfs-snapshots.conf")
	require.NoError(t, err)
	require.NotNil(t, diff)
	
	content := diff.Modified
	
	// Verify header
	assert.Contains(t, content, "# WARNING - Submenu options will be overwritten automatically,")
	assert.Contains(t, content, "# but menuentry attributes will be maintained.")
	
	// Should contain template with disabled directive
	assert.Contains(t, content, "# TEMPLATE ENTRY - Customize this example")
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")
	assert.Contains(t, content, "    disabled")
	assert.Contains(t, content, "    icon     /EFI/refind/icons/os_arch.png")
	assert.Contains(t, content, "    loader   /boot/vmlinuz-linux")
	assert.Contains(t, content, "    initrd   /boot/initramfs-linux.img")
	assert.Contains(t, content, "# INSTRUCTIONS:")
	assert.Contains(t, content, "# 1. Remove or comment out the 'disabled' line above")
	
	// Should use options from source entry
	assert.Contains(t, content, "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid")
	
	// Should contain example submenus
	assert.Contains(t, content, "    submenuentry \"Arch Linux (")
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/101/snapshot")
	
	// Should be marked as a new file
	assert.True(t, diff.IsNew)
}

func TestGenerateManagedConfigDiff_ExistingFile_PreservesCustomizations(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	// Create test snapshots
	now := time.Now()
	snapshots := []*btrfs.Snapshot{
		{
			Subvolume: &btrfs.Subvolume{
				ID:   101,
				Path: "/.snapshots/101/snapshot",
			},
			SnapshotTime: now.Add(-1 * time.Hour),
		},
	}
	
	sourceEntries := []*MenuEntry{
		{
			Title:   "Boot with standard options",
			Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
		},
	}
	
	rootFS := &btrfs.Filesystem{
		UUID: "test-uuid",
		Subvolume: &btrfs.Subvolume{
			Path: "@",
		},
	}
	
	// Create a temporary file with existing content
	tmpDir := t.TempDir()
	configPath := filepath.Join(tmpDir, "refind-btrfs-snapshots.conf")
	
	existingContent := `# Generated by refind-btrfs-snapshots
# WARNING - Submenu options will be overwritten automatically,
# but menuentry attributes will be maintained.

menuentry "Arch Linux" {
    icon /EFI/refind/icons/custom_arch.png
    loader /boot/vmlinuz-linux
    initrd /boot/initramfs-linux.img
    options quiet custom_param=1 rw rootflags=subvol=@ root=UUID=test-uuid
}

menuentry "Arch Linux LTS" {
    icon /EFI/refind/icons/os_arch_lts.png
    loader /boot/vmlinuz-lts
    initrd /boot/initramfs-lts.img
    options quiet rw rootflags=subvol=@ root=UUID=test-uuid
}`
	
	err := os.WriteFile(configPath, []byte(existingContent), 0644)
	require.NoError(t, err)
	
	// Generate config for existing file
	diff, err := generator.GenerateManagedConfigDiff(sourceEntries, snapshots, rootFS, configPath)
	require.NoError(t, err)
	require.NotNil(t, diff)
	
	content := diff.Modified
	
	// Should preserve both existing entries
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")
	assert.Contains(t, content, "menuentry \"Arch Linux LTS\" {")
	
	// Should preserve custom attributes
	assert.Contains(t, content, "icon /EFI/refind/icons/custom_arch.png")
	assert.Contains(t, content, "icon /EFI/refind/icons/os_arch_lts.png")
	assert.Contains(t, content, "loader /boot/vmlinuz-linux")
	assert.Contains(t, content, "loader /boot/vmlinuz-lts")
	assert.Contains(t, content, "custom_param=1")
	
	// Should add snapshot submenus to both entries
	assert.Contains(t, content, "submenuentry \"Arch Linux (")
	assert.Contains(t, content, "submenuentry \"Arch Linux LTS (")
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/101/snapshot")
	
	// Should not be marked as a new file
	assert.False(t, diff.IsNew)
}

func TestGenerateMenuTitle(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	tests := []struct {
		name          string
		groupKey      string
		templateEntry *MenuEntry
		expected      string
	}{
		{
			name:     "vmlinuz-linux_loader",
			groupKey: "vmlinuz-linux",
			templateEntry: &MenuEntry{
				Loader: "/boot/vmlinuz-linux",
			},
			expected: "Arch Linux",
		},
		{
			name:     "vmlinuz-lts_loader",
			groupKey: "vmlinuz-lts",
			templateEntry: &MenuEntry{
				Loader: "/boot/vmlinuz-lts",
			},
			expected: "Arch Linux LTS",
		},
		{
			name:     "bzImage_loader",
			groupKey: "bzImage",
			templateEntry: &MenuEntry{
				Loader: "/boot/bzImage",
			},
			expected: "Linux",
		},
		{
			name:     "existing_base_name",
			groupKey: "Custom Linux",
			templateEntry: &MenuEntry{
				Loader: "/boot/vmlinuz-linux",
			},
			expected: "Custom Linux",
		},
		{
			name:     "fallback_to_title",
			groupKey: "",
			templateEntry: &MenuEntry{
				Title:  "Fallback Title",
				Loader: "",
			},
			expected: "Fallback Title",
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.generateMenuTitle(tt.groupKey, tt.templateEntry)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestExtractBaseName(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	tests := []struct {
		name     string
		title    string
		expected string
	}{
		{
			name:     "title_with_timestamp",
			title:    "Boot with standard options (2025-06-12_07-00-18)",
			expected: "Boot with standard options",
		},
		{
			name:     "title_without_timestamp",
			title:    "Boot with standard options",
			expected: "Boot with standard options",
		},
		{
			name:     "title_with_spaces_and_timestamp",
			title:    "Arch Linux LTS Kernel (2024-01-15_10-30-00)",
			expected: "Arch Linux LTS Kernel",
		},
		{
			name:     "empty_title",
			title:    "",
			expected: "",
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.extractBaseName(tt.title)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGroupEntriesByBase(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	entries := []*MenuEntry{
		{Title: "Boot with standard options (2025-06-12_07-00-18)"},
		{Title: "Boot with standard options (2025-06-12_06-00-13)"},
		{Title: "Boot to single-user mode (2025-06-12_07-00-18)"},
		{Title: "Custom Entry"},
	}
	
	groups := generator.groupEntriesByBase(entries)
	
	// Should have 3 groups
	assert.Len(t, groups, 3)
	
	// Check "Boot with standard options" group
	assert.Len(t, groups["Boot with standard options"], 2)
	
	// Check "Boot to single-user mode" group
	assert.Len(t, groups["Boot to single-user mode"], 1)
	
	// Check "Custom Entry" group
	assert.Len(t, groups["Custom Entry"], 1)
}

func TestParseExistingManagedConfig(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	existingConfig := `# Generated by refind-btrfs-snapshots
# WARNING - Submenu options will be overwritten automatically,
# but menuentry attributes will be maintained.

menuentry "Arch Linux" {
    icon /EFI/refind/icons/os_arch.png
    loader /boot/vmlinuz-linux
    initrd /boot/initramfs-linux.img
    options quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid
    submenuentry "Arch Linux (2025-06-12_05-00-03)" {
        options quiet rw rootflags=subvol=@/.snapshots/375/snapshot root=UUID=test-uuid
    }
}

menuentry "Custom Entry" {
    icon /EFI/refind/icons/custom.png
    volume LABEL=CUSTOM
    loader /custom/kernel
    options custom-options
}`
	
	entries := generator.parseExistingManagedConfig(existingConfig)
	
	// Should have parsed 2 entries
	assert.Len(t, entries, 2)
	
	// Check "Arch Linux" entry
	archEntry, exists := entries["Arch Linux"]
	require.True(t, exists)
	assert.Equal(t, "Arch Linux", archEntry.Title)
	assert.Equal(t, "/EFI/refind/icons/os_arch.png", archEntry.Icon)
	assert.Equal(t, "/boot/vmlinuz-linux", archEntry.Loader)
	assert.Equal(t, "/boot/initramfs-linux.img", archEntry.Initrd)
	assert.Equal(t, "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid", archEntry.Options)
	
	// Check "Custom Entry" entry
	customEntry, exists := entries["Custom Entry"]
	require.True(t, exists)
	assert.Equal(t, "Custom Entry", customEntry.Title)
	assert.Equal(t, "/EFI/refind/icons/custom.png", customEntry.Icon)
	assert.Equal(t, "LABEL=CUSTOM", customEntry.Volume)
	assert.Equal(t, "/custom/kernel", customEntry.Loader)
	assert.Equal(t, "custom-options", customEntry.Options)
}

func TestMergeCustomizations(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	template := &MenuEntry{
		Title:   "Template",
		Loader:  "/boot/vmlinuz-linux",
		Options: "template-options",
	}
	
	existing := &MenuEntry{
		Title:   "Custom Title",
		Icon:    "/custom/icon.png",
		Volume:  "LABEL=CUSTOM",
		Loader:  "/custom/loader",
		Initrd:  "/custom/initrd",
		Options: "custom-options",
	}
	
	merged := generator.mergeCustomizations(template, existing)
	
	// Should preserve customizations from existing
	assert.Equal(t, "Template", merged.Title) // Title should remain from template
	assert.Equal(t, "/custom/icon.png", merged.Icon)
	assert.Equal(t, "LABEL=CUSTOM", merged.Volume)
	assert.Equal(t, "/custom/loader", merged.Loader)
	assert.Equal(t, "/custom/initrd", merged.Initrd)
	assert.Equal(t, "custom-options", merged.Options)
	
	// Should have empty submenues (they get regenerated)
	assert.Empty(t, merged.Submenues)
}

func TestGenerateSingleMenuEntry(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	templateEntry := &MenuEntry{
		Icon:    "/EFI/refind/icons/os_arch.png",
		Loader:  "/boot/vmlinuz-linux",
		Initrd:  "/boot/initramfs-linux.img",
		Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
	}
	
	snapshots := []*btrfs.Snapshot{
		{
			Subvolume: &btrfs.Subvolume{
				ID:   101,
				Path: "/.snapshots/101/snapshot",
			},
			SnapshotTime: time.Date(2025, 6, 12, 7, 0, 18, 0, time.UTC),
		},
	}
	
	rootFS := &btrfs.Filesystem{
		UUID: "test-uuid",
	}
	
	content := generator.generateSingleMenuEntry("Arch Linux", templateEntry, snapshots, rootFS)
	
	// Should contain menuentry
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")
	
	// Should contain all template attributes
	assert.Contains(t, content, "    icon /EFI/refind/icons/os_arch.png")
	assert.Contains(t, content, "    loader /boot/vmlinuz-linux")
	assert.Contains(t, content, "    initrd /boot/initramfs-linux.img")
	assert.Contains(t, content, "    options quiet rw rootflags=subvol=@ root=UUID=test-uuid")
	
	// Should contain submenu for snapshot
	assert.Contains(t, content, "    submenuentry \"Arch Linux (2025-06-12_07-00-18)\" {")
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/101/snapshot")
	assert.Contains(t, content, "subvolid=101")
	assert.Contains(t, content, "root=UUID=test-uuid")
	assert.Contains(t, content, "    }")
	
	// Should end with closing brace
	assert.Contains(t, content, "}")
}

func TestGenerateManagedConfigDiff_PreservesCustomizations(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	// Create a temporary file with existing content
	existingContent := `# Generated by refind-btrfs-snapshots
# WARNING - Submenu options will be overwritten automatically,
# but menuentry attributes will be maintained.

menuentry "Arch Linux" {
    icon /EFI/refind/icons/custom_arch.png
    volume LABEL=CUSTOM_ESP
    loader /boot/vmlinuz-linux
    initrd /boot/initramfs-linux.img
    options quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid custom_param=1
}`
	
	// Test the parsing function directly
	existingEntries := generator.parseExistingManagedConfig(existingContent)
	
	// Should have found the existing entry
	require.Len(t, existingEntries, 1)
	
	archEntry, exists := existingEntries["Arch Linux"]
	require.True(t, exists)
	
	// Should have preserved custom attributes
	assert.Equal(t, "/EFI/refind/icons/custom_arch.png", archEntry.Icon)
	assert.Equal(t, "LABEL=CUSTOM_ESP", archEntry.Volume)
	assert.Equal(t, "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid custom_param=1", archEntry.Options)
}

func TestUpdateOptionsForSnapshot_AvoidDoubleAt(t *testing.T) {
	generator := NewGenerator("/boot/efi")
	
	snapshot := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   101,
			Path: "/.snapshots/101/snapshot", // Path without @
		},
	}
	
	snapshotWithAt := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   102,
			Path: "@/.snapshots/102/snapshot", // Path already with @
		},
	}
	
	originalOptions := "quiet rw rootflags=subvol=@ root=UUID=test-uuid"
	
	// Test normal case: path without @
	result1 := generator.updateOptionsForSnapshot(originalOptions, snapshot)
	assert.Contains(t, result1, "rootflags=subvol=@/.snapshots/101/snapshot")
	assert.NotContains(t, result1, "@@") // Should not have double @
	
	// Test case where path already has @: should not get double @
	result2 := generator.updateOptionsForSnapshot(originalOptions, snapshotWithAt)
	assert.Contains(t, result2, "rootflags=subvol=@/.snapshots/102/snapshot")
	assert.NotContains(t, result2, "@@") // Should not have double @
}